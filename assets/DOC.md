<!-- This is the doc file for Bembel, v0.1. -->
# Bembel
[Back to the main page.](../README.md)

## Online Documentation

This is the first version of the online documentation of Bembel. Currently,
it is rather brief, discussing the structure of the examples, and explain 
how simple changes can be made. The functionality of the Laplace, 
Helmholtz and Maxwell case are very similar.

### Table of Contents

1. [Initial Setup](#init)
2. [Geometry and Discretization](#disc)
3. [Data and Right Hand Side](#rhs)
4. [Matrix Assembly](#assembly) 
5. [Iterative Solver](#solve)
6. [Postprocessing](#eval)
7. [Tools and Visualization](#tools)

### Initial Setup <a name="init"></a>

We will start by going through the initial setup.

#### Header Files

The API is designed such that, for executables, only header files ending in
`.hpp`, header files of Eigen and header files of the STL need to be 
loaded. We will briefly discuss the `.hpp` files and their respective 
functionality.

* `Data.hpp` includes functions which can be used to assemble the right hand 
side and induce problems with analytical solutions.
* `Discretization.hpp` includes the Discretization class. Its constructor 
takes a Geometry object, the type of PDE and some other parameters as input and
sets up a suitable discrete space.
* `EvalSolution.hpp` contains functions for the evaluation of the solution in 
the interior or exterior domain.
* `Error.hpp` contains small functions to evaluate the pointwise error, if an 
analytical solution in the domain is known.
* `Geometry.hpp` handles the representation of the geometry. Its constructor 
loads a `.dat` file whose path is passed as a `std::string`, consisting of a 
geometry made up of surface patches with outward pointing normal vectors, 
in the format of Octaves NURBS package. The geometry needs to be watertight
and the edges need to be parameterized such that the underlying BÃ©zier meshes 
coincide. Beyond that, the direction of parametrization does not matter, i.e., 
for two patches *F(x,y)* and *G(x,y)* with a common edge with *x=0*, 
either *F(0,y)=G(0,y)*  or *F(0,1-y)=G(0,y)* needs to be fulfilled. 
This ensures that, for orientable manifolds, all patches can be (re)parametrized
such that the normal vector is outward directed.
* `Grids.hpp` contains two routines to initialize points int the domain, for 
postprocessing and evaluation of the solution. These two functions will be 
discussed in the Postprocessing section.
* `HierarchicalMatrix.hpp` includes the wrapper class for interfacing the 
compressed system matrix, which is generated by the Discretization object and
further input parameters, discussed in the upcoming subsection. The constructor
assembles the matrix induced by the discretization and the PDE.
* `Logger.hpp` contains a helper class to write logs.
* `PDEproblem.hpp` contains Classes encoding the properties of the three 
supported PDEs and the respective approaches. It must not be modified and merely 
instantiated to be passed to other classes.
* `Rhs.hpp` contains wrappers for the low-level routines to assemble the right
hand side of the problem.
* `Spline.hpp` includes all necessary headers for geometry evaluation, 
evaluation of basis functions, and assembly of suitable discrete spaces.
* `Stopwatch.hpp` contains a helper class for benchmarking and time measurements.

#### Parameters

The following parameters appear in the examples and can be modified by the user.

* `knotrepetition` is passed to the Discretization object. This can be used to
apply knot-repetition when refining within the spline space on each patch.
* `multipoleDegree` can be passed to the HMatrix to influence the accuracy of
the low-rank approximation in each block.
* `P` is passed to the Discretization and chooses the order of ansatz function.
The current maximum is set to 18 but could be changed, since the higher order
ansatz functions are generated via template recursion.
* `M` sets the number of uniform refinements w.r.t. the reference domain which
is applied to the discrete spaces. 
This means *M=0 -> h=1*, *M=1 -> h=0.5*, *M=2 -> h=0.25*, ...

### Geometry and Discretization <a name="disc"></a>

A valid discretization can be invoke via 

```C++
PDEtype myPDE;
Geometry geom("file.dat");
Discretization<PDEtype> myDisc(geom, myPDE, P, kr,M);
```

For the geometry, we require that patches *F(x,y)* and *G(x,y)* with (w.l.o.g.) common interface *x=0* fulfill the matching condition *F(0,y)=G(0,y)*  or *F(0,1-y)=G(0,y)*. This means that, along common edges, the parametrisation may be in opposing direction. However, we have a strong requirement on the normal vector, which needs to be be outward directed on all geometries. We have routines in place which will check weather all patches are oriented the same and will throw an error if the condition is not fulfilled. A consequence of this is that we can currently only compute solutions on orientable geometries.

When generating geometries for a computation, which can be done, for example, via the NURBS package of octave as showcased in the octave script `geo/octave_example/example.m`, one needs to be wary of the orientation of the normal vectors. As of now, single patches have to be turned by hand.

The CMake file automatically generates a binary called `VisualizeDatfile.out`, which will, when called as `./VisualizeDatfile.out "path/to/datfile.dat` generate a `geometry.vtk` file which visualizes the geometry stored in `datfile.dat`. This can be used as a helper in creating the geometries. 

In an upcoming release, we will add a method to the Geometry class automating this process.

Already implemented methods of the Geometry class allow do deform the loaded geometry. Specifically
```C++
  void Geometry::deform(Eigen::Matrix<double, 3, 3> trafo);
  void Geometry::rotate(double x, double y, double z);
  void Geometry::stretch(double x, double y, double z);
```
are available. The first allows for an arbitrary transformation matrix `trafo` to be applied to the geometry. `rotate` calls `deform` with a rotation matrix generated by rotations of `x` radians around the x-axis, `y` in y-axis, ... .  `stretch` will stretch (or stouch) the geometry by a `double` factor in the respective direction.

With regards to the discretization, the variables `P, M, kr` in the code snipped above can be chosen on a case by case basis, and PDEtype corresponds
to either `LaplaceSingle`, `HelmholtzSingle`, or `MaxwellSingle`. `myDisc` will
then construct the discrete space, which corresponds to the spaces constructed 
in [this ArXiv preprint](https://arxiv.org/abs/1806.01062). For the scalar 
problems (Laplace and Helmholtz) `P=0` will construct a basis of locally 
constant functions, `P=1` linear, ... . Within patches, the basis will be 
continuous for higher values `P`; across patch boundaries, the space will be 
discontinuous. In the Maxwell case, `P=0` will throw an error: For the required
divergence conforming basis continuity of the normal component across patch
interfaces is required, which can only be achieved with `P>0`. The spaces in 
the Maxwell case will have the structure `[P x P-1;P-1 x P]`; thus the 
convergence order to be expected is governed by `P-1`.

### Data and Right Hand Side <a name="rhs"></a>

Given a valid discretization, a right-hand side can be assembled via the 
`computeRhs` routines within the `namespace Rhs`, see also `include/Rhs.hpp`. 
The data/function to induce the right-hand side can be set in `main()` as a 
`std::function`, where the required type signatures are

* `std::function<double(Eigen::Vector3)>` for Laplace,
* `std::function<std::complex<double>(Eigen::Vector3)>` for Helmholtz, and
* `std::function<Eigen::Vector3cd(Eigen::Vector3)>` for Maxwell.

We provide for each PDE one such example in the `data.hpp` header, see the 
files in `src/examples/`.
Afterwards, the right-hand side is assembled by simply calling

```C++
Eigen::VectorXcd rhs = Rhs::computeRhs(myDisc, fun); 
```

For the scalar problems, the L2-scalar product is utilized to project the data
to the discrete space. For Maxwell, the duality product involving a normal
rotation is used, see [this ArXiv preprint](https://arxiv.org/abs/1807.03097) 
for further information. Note that, in the Laplace case, the output is real-valued.

In the examples, all these functions invoke a *manufactured solution*, i.e., 
a non-trivial solution to each PDE, respectively. Thus, these functions can be 
used for convergence studies. Therein, it is important to evaluate the solution
in the interior or exterior domain, respectively, depending on where the 
manufactured solution fulfils the given problem, i.e., in the exterior including
the respective radiation condition.

#### Ordering of the Degrees of Freedom

If you want to use measurement data or want to interface different 
libraries/tools, the ordering of degrees of freedom becomes relevant. 

The coefficient vectors in the Laplace and Helmholtz case are ordered one patch 
after the other, and degrees of freedom in y-major, i.e, the tensor product
basis functions in the x-direction are in the inner loops.

For Maxwell, this applies as well, but the two vector components come one after 
another. However, since normal continuity is required, some degrees of freedom
are eliminated and identified with another. How this is done exactly depends on
the topology of the loaded geometry.

### Matrix Assembly <a name="assembly"></a>

Matrix assembly in the main-file is simply achieved by passing a Discretization
object to the constructor of the `Eigen::HierarchicalMatrix<PDEtype>` class.
It is constructed, such that matrix-vector multiplication with Eigen vectors is 
supported, and returns an Eigen vector. Currently, there are some issues with 
the in-place mechanisms of Eigen. It might be necessary to use the `.eval()` 
method on the vector beforehand. 

The matrix is assembled as explained in 
[this ArXiv preprint](https://arxiv.org/abs/1708.09162) for the scalar cases, 
and in 
[this ArXiv preprint](https://arxiv.org/abs/1807.03097) for the Maxwell case. 

The constructor can be invoked in one of the following ways

```C++
Eigen::HierarchicalMatrix<PDEtype> H1(myDisc);
Eigen::HierarchicalMatrix<PDEtype> H2(myDisc, multipoleDegree);
Eigen::HierarchicalMatrix<PDEtype> H3(myDisc, multipoleDegree, eta);
```

The first option uses standard parameters, which should be sufficient for most 
applications. In the second case, `multipoleDegree` is an integer, which 
influences the accuracy of the low-rank approximation. It corresponds to *q* in
the cited literature. The third variant allows passing the parameter `eta` as a 
`double`, which is the same eta as used in the admissibility condition used in
the construction of the block-cluster tree.

#### A Note on Quadratures 

Currently, changing the order of quadrature is not supported through the high 
level API. The code uses a heuristic, which will yield asymptotically correct 
behaviour w.r.t. *M*. However, when using *p* refinement or other techniques 
which are very snesitive w.r.t. quadrature, the heuristic might need to be 
changed. It can be changed in the routines 
`static int <PDEtype>_quadrature_order(int,double,int,int)` found in the 
`src/bemlibC/pdeproblem_<PDEtype>.cpp` files. In the respective commentary 
more information on the utilized heuristic are available. **We advise not to 
change it unless absolutely necessary.**

### Iterative Solver <a name="solve"></a>

Since the HierarchicalMatrix is wrapped into an Eigen::Base object, some
functionality within the framework of Eigen may be used. In particular, the 
linear system can be solved by the iterative solvers of Eigen. Currently only 
`Eigen::IdentityPreconditioner` is supported. We recommend the CG for Laplace 
and the GMRES of the unsupported module for the complex problems.

### Postprocessing <a name="eval"></a>

Having the density vector `rho` from the iterative solver, the solution to the
PDE in either exterior or interior domain can be evaluated by the function

```C++
auto sol = Sol::evalSolution(gridpoints, rho, myDisc);
```

in here, gridpoints should be an `Eigen::Matrix<double, Eigen::Dynamic, 3>` 
matrix of *n* three-dimensional points in the domain of interest, and, 
depending on the PDEtype, `sol` is either a `VectorXd`, `VectorXcd` or
`Eigen::Matrix<std::complex<double>, Eigen::Dynamic, 3>`, corresponding to the 
pointwise solution at the corresponding gridpoint.
 
### Tools and Visualization <a name="tools"></a>

We ship some tools for simplified setup of numerical experiments.

* The `Bembel::Util::Logger` class, which can be used to write logs or print to 
the console. You can pass a filename, a separator `std::string`, i.e., to write
`.csv` files and an opening mode for the file to the constructor see 
`Logger.hpp`. It will always write all input parameters to either the terminal
by calling `.term(args..)`, the file by calling `.file(args..)`, or 
`.both(args...)`. The template parameter of the class can be used to set the
(uniform) width of each column.
* The `Bembel::Util::Stopwatch` class, which can be used for time measurements,
based on `std::chrono`. Its functionality is self explanatory, see e.g. the 
`src/examples/example_LaplaceSingle.cpp` file.
* The `Bembel::Util::makeTensorProductGrid(x,y,z)` function, which can be used 
to create a vector `Eigen::Matrix<double, Eigen::Dynamic, 3>` of points for the
evaluation of the solution. It simply assembles a tensor product pointset 
induced by the three `VectorXd`s `x,y,z`. 
* The `Bembel::Util::makeSphereGrid(r,n,center)` function, which also can be 
used to creates an `Eigen::Matrix<double, Eigen::Dynamic, 3>` of points on a 
sphere for the evaluation of the solution. *n^2* points are placed on the sphere
with radius `double r` around the point `Eigen::Vector3d center`.
* The `Bembel::errors` and `Bembel::maxPointwiseError` functions, which take the
output of `Sol::EvalSolution`, the corresponding grid, and a `std::function`
representing an analytical solution, and compute a vector of the errors at each
point, or the maximum error, respectively.
* The `Bembel::Vis::plotDiscretizationToVTK` function(s), which can be used to
visualize `rho` and the geometry in `.vtk` format. Their functionality is
explained extensively in the `src/examples/example_Visualization.cpp` file.
